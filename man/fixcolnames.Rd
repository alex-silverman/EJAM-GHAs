% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fixcolnames.R
\name{fixcolnames}
\alias{fixcolnames}
\title{helper function to rename variables that are colnames of data.frame}
\usage{
fixcolnames(namesnow, oldtype = "csvname", newtype = "r", mapping_for_names)
}
\arguments{
\item{namesnow}{vector of colnames to be renamed}

\item{oldtype}{"longname" or "shortname", or "csv" or "r" or "api", etc.
or a colname of map_headernames, used if one of those known types was not specified.}

\item{newtype}{"longname" or "shortname", or "csv" or "r" or "api", etc.
or a colname of map_headernames, used if one of those known types was not specified.}

\item{mapping_for_names}{default is a dataset already in the package.}
}
\value{
Vector or new column names same length as input
}
\description{
Changes variable names like colnames to long plain-English headers or short labels for plots
}
\details{
You specify an alias of a type like "api", "r", "long", or "short",
or one of \code{colnames(map_headernames)} like "rname", "vartype", "decimals", "varlist", etc.

Also, you can use this to extract any info from \code{map_headernames} (which
here is called mapping_for_names).

NOTE: if you ask to rename your words to a known type like rname or apiname, and
the namesnow is not found among the oldtype, then it is not renamed, and those are returned as unchanged.
BUT, if you specify as newtype some column that is not a known type of name, like "varcategory"
then it will instead return an empty string for those in namesnow that are not found among the oldtype.
That way if you are really seeking a new name, but it cannot rename, it keeps the old name
while if you are really seeking metadata like what category it is in,
it returns a blank if the old name is not found at all.

These are some key column names in the \link{map_headernames} table:
\itemize{
\item "shortname" (aka "short", for plot labels, etc.)
\item "longname" (aka "long", for full explanatory headers to use on a table)
\item "rname" (aka "r", the R variable names as used in the EJAM code)
\item "apiname" (aka "api", as returned by EJScreen API)
\item "csvname" (aka "csv", as found in the CSV files of just the key residential population and environmental indicators, found on the EJScreen FTP site)
\item "acsname" (aka "acs", as found in a ACS data file internally used by EJScreen, containing all the extra residential population groups and other indicators not stored in the CSV files on the EJScreen FTP site)
\item "DEJ" (whether the indicator is residential population, environmental, etc.)
\item "varlist" (which group of names is this variable in, such as "names_d", "names_d_subgroups", "names_d_state_pctile", etc.)
\item "calculation_type" (how it should be aggregated over block groups, such as "wtdmean", "sum of counts", etc.)
\item "denominator" (the weight to use in aggregating as a wtdmean, normally a count variable that is the universe for a percentage, such as "pop", "hhlds", etc.)
}
}
\examples{
 # see package tests
  
 names_d
 namesbyvarlist('names_d')
 x = varinfo("pctlowinc")
 x = varinfo("pcthisp")
 

 # see the different names for the same variable, 
 # and see it is not in the csv tables on the FTP site
 varinfo("pcthisp", c("csvname", "acsname", "apiname"))

 # EJAM:::names_whichlist("RAW_D_INCOME")
 fixcolnames(c("RAW_D_INCOME", "S_D_LIFEEXP"), 'api')
 fixcolnames('LOWINCPCT', 'csv')
 fixcolnames(c("PCT_HISP", "HISP"), 'acs')
 fixcolnames(c("RAW_D_INCOME", "S_D_LIFEEXP"), newtype = "longname")

 addmargins(table(map_headernames$vartype, map_headernames$DEJ))
  
  # the columns "newsort" and "reportsort" provide useful sort orders
  x <- map_headernames$rname[map_headernames$varlist == "names_d"]
  # same as 
  
  print("original order"); print(x) 
  x <-  sample(x, length(x), replace = FALSE)   
  print("out of order"); print(x)
  print("fixed order")
  x[ order(fixcolnames(x, oldtype = "r", newtype = "newsort")) ]

}
\seealso{
\code{\link[=varinfo]{varinfo()}}
}
