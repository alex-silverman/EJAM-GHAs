% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distances.all.R
\name{distances.all}
\alias{distances.all}
\title{Find all distances between two sets of points (based on lat/lon)}
\usage{
distances.all(
  frompoints,
  topoints,
  units = "miles",
  return.crosstab = FALSE,
  return.rownums = TRUE,
  return.latlons = TRUE,
  as.df = TRUE
)
}
\arguments{
\item{frompoints}{A matrix or data.frame with two cols, 'lat' and 'lon' with datum=WGS84 assumed.}

\item{topoints}{A matrix or data.frame with two cols, 'lat' and 'lon' with datum=WGS84 assumed.}

\item{units}{A string that is 'miles' by default, or 'km' for kilometers,
specifying units for distances returned.}

\item{return.crosstab}{Logical value, FALSE by default. If TRUE, value returned is a matrix of the distances,
with a row per frompoint and col per topoint.}

\item{return.rownums}{Logical value, TRUE by default. If TRUE, value returned also includes two extra columns:
a col of index numbers starting at 1 specifying the frompoint and a similar col specifying the topoint.
If crosstab=TRUE, ignores return.rownums and return.latlons}

\item{return.latlons}{Logical value, TRUE by default. If TRUE, value returned also includes four extra columns,
showing fromlat, fromlon, tolat, tolon.
If crosstab=TRUE, ignores return.rownums and return.latlons}

\item{as.df}{Logical, default is TRUE, in which case returns a data.frame (unless vector), otherwise a matrix (unless vector).}
}
\value{
By default, returns a dataframe that has 3 columns: fromrow, torow, distance
(where fromrow or torow is the row number of the corresponding input, starting at 1).
If return.crosstab=FALSE, which is default, and return.rownums and/or return.latlons is TRUE,
returns a row per from-to pair, and columns depending on parameters, sorted first cycling through all topoints for first frompoint, and so on.
If return.crosstab=FALSE and return.rownums and return.latlons are FALSE, returns a vector of distances in same order as rows described above.
If return.crosstab=TRUE, returns a matrix of distances, with one row per frompoint and one column per topoint.
}
\description{
Returns all the distances from one set of geographic points to another set of points.
Can return a matrix of distances (m x n points) or vector or data.frame with one row per pair.
Lets you specify units and whether you need lat/lon etc, but essentially just a wrapper for
the \pkg{sf} package for the \link[sf:geos_measures]{sf::st_distance} and \link[sf:st_as_sf]{sf::st_as_sf} functions.
}
\details{
\preformatted{
  *** Probably slower than it needs to be partly by using data.frame 
   instead of matrix class? Maybe 10-20 percent faster if as.df=FALSE than if TRUE 
  Just using distances.all is reasonably fast? 
  When it was still using sp and not sf package, it was 
    (30-40 seconds for 
    100 million distances, but slow working with results so large),
 Sys.time(); x=distances.all(testpoints_n(1e5), testpoints_n(1000), 
   return.crosstab=TRUE); Sys.time()  
 
       IF NO PROCESSING OTHER THAN CROSSTAB 
 Sys.time(); x=distances.all(testpoints_n(1e6), testpoints_n(100),
    return.crosstab=TRUE); Sys.time() 
 
       (1m x 100, or 100k x 1000) 
 Sys.time(); x=distances.all(testpoints_n(1e6), testpoints_n(300), 
   return.crosstab=TRUE); Sys.time() 
    seconds for 300 million pairs.  
  plus_____ seconds or so for x[x>100] <- Inf  
       # so 11m blocks to 1k points could take >xxx minutes! 
       (you would want to more quickly remove the ones outside some radius) 
        
           About xxx seconds per site for 11m blocks?  
           
    Sys.time(); x=distances.all(testpoints_n(1e5), testpoints_n(1000), 
      units='miles',return.rownums=TRUE); Sys.time() 
  xxx SECONDS IF DATA.FRAME ETC. DONE 
      TO FORMAT RESULTS AND GET ROWNUMS
   Sys.time(); x=distances.all(testpoints_n(1e5), testpoints_n(1000), 
     units='miles',return.rownums=TRUE)$d; Sys.time()
   xxx SECONDS IF DATA.FRAME ETC. DONE 
      TO FORMAT RESULTS AND GET ROWNUMS IN distances.all 
    }
}
\examples{
set.seed(999)
t1=testpoints_500[1,c("lon", "lat")]
t10=testpoints_500[1:10,c("lon", "lat")]
t100=testpoints_500[1:100,c("lon", "lat")]
t1k=rbind(testpoints_500, testpoints_500)

distances.all(t1, t1)
distances.all(t1, t10[2, , drop = FALSE])
x=distances.all(t10, t100[1:20 , ], units = 'km')
 plot(x$tolon, x$tolat,pch='.')
 points(x$fromlon, x$fromlat)
 with(x, linesegments(fromlon, fromlat, tolon, tolat ))
 with(x[x$d < 500, ], linesegments(fromlon, fromlat, tolon, tolat ,col='red'))

   test.from <- structure(list(fromlat = c(38.9567309094, 45),
     fromlon = c(-77.0896572305, -100)), .Names = c("lat", "lon"),
     row.names = c("1", "2"), class = "data.frame")

   test.to <- structure(list(tolat = c(38.9575019287, 38.9507043428, 45),
    tolon = c(-77.0892818598, -77.2, -90)),
    .Names = c("lat", "lon"), class = "data.frame",
    row.names = c("1", "2", "3"))
 test.to.NA = rbind(c(NA,NA), test.to[2:3,])
 test.from.NA = rbind(test.from[1,], c(NA,NA))
 
distances.all(test.from, test.to)
distances.all(test.from, test.to, return.crosstab=TRUE)
distances.all(test.from, test.to, return.rownums=FALSE)
distances.all(test.from, test.to, return.latlons=FALSE)
distances.all(test.from, test.to, return.latlons=FALSE, 
  return.rownums=FALSE)

     # test cases
distances.all(test.from,    test.to.NA)
distances.all(test.from.NA, test.to)
distances.all(test.from.NA, test.to.NA)
distances.all(test.from[1,],test.to[1,],return.rownums=F,
return.latlons=F)
distances.all(test.from[1,],test.to[1,],return.rownums=FALSE,
return.latlons=TRUE)
distances.all(test.from[1,],test.to[1,],return.rownums=TRUE,
return.latlons=FALSE)
distances.all(test.from[1,],test.to[1,],return.rownums=TRUE,
return.latlons=TRUE)

distances.all(test.from[1,],test.to[1:3,],return.rownums=F,
return.latlons=F)
distances.all(test.from[1,],test.to[1:3,],return.rownums=FALSE,
return.latlons=TRUE)
distances.all(test.from[1,],test.to[1:3,],return.rownums=TRUE,
return.latlons=FALSE)
distances.all(test.from[1,],test.to[1:3,],return.rownums=TRUE,
return.latlons=TRUE)

distances.all(test.from[1:2,],test.to[1,],return.rownums=F,
return.latlons=F)
distances.all(test.from[1:2,],test.to[1,],return.rownums=FALSE,
return.latlons=TRUE)
distances.all(test.from[1:2,],test.to[1,],return.rownums=TRUE,
return.latlons=FALSE)
distances.all(test.from[1:2,],test.to[1,],return.rownums=TRUE,
return.latlons=TRUE)

round(distances.all(test.from[1:2,],test.to[1:3,],return.rownums=F,
return.latlons=F),1)
distances.all(test.from[1:2,],test.to[1:3,],return.rownums=FALSE,
return.latlons=T)
distances.all(test.from[1:2,],test.to[1:3,],return.rownums=TRUE,
return.latlons=F)
distances.all(test.from[1:2,],test.to[1:3,],return.rownums=TRUE,
return.latlons=TRUE)
distances.all(test.from[1:2,],test.to[1:3,], return.rownums=TRUE,
  return.latlons=TRUE, units='km')
distances.all(test.from[1:2,],test.to[1:3,], return.rownums=TRUE,
  return.latlons=TRUE, units='miles')

distances.all(test.from[1,],test.to[1:3, ], return.crosstab=TRUE)
distances.all(test.from[1:2,],test.to[1, ], return.crosstab=TRUE)
round(distances.all(test.from[1:2,],test.to[1:3, ],
return.crosstab=TRUE, units='miles'),2)
round(distances.all(test.from[1:2,],test.to[1:3, ],
return.crosstab=TRUE, units='km'),2)


}
\seealso{
\code{\link[=latlon_infer]{latlon_infer()}} get.distances() which allows you to specify a search radius and
get distances only within that radius which can be faster,
get.distances.prepaired() for finding distances when data are already formatted as pairs of points,
get.nearest() which finds the distance to the single nearest point
within a specified search radius instead of all topoints, and
proxistat or proxistat2  which will which create a proximity score for each spatial unit
based on distances to nearby points.
}
